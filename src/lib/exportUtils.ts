/**
 * Export and reporting utilities for Upsert.
 *
 * Provides functions to generate Markdown, HTML, CSV, and JSON reports
 * from schema diffs, data diffs, and migration results, plus a browser
 * download helper.
 */

import type {
  SchemaDiffResult,
  SchemaChange,
  DataDiffRow,
} from "../types/comparison";
import type {
  MigrationConfig,
  MigrationProgress,
  TableMapping,
  TransformRule,
  TableProgress,
  DryRunResult,
} from "../stores/migrationStore";

// ---------------------------------------------------------------------------
// Local types used exclusively by the export utilities
// ---------------------------------------------------------------------------

/** Input for pre-migration plan export. */
export interface MigrationPlanExport {
  config: MigrationConfig;
  tableMappings: TableMapping[];
  transformRules: TransformRule[];
  dryRunResult: DryRunResult | null;
}

/** Input for post-migration summary export. */
export interface MigrationResultExport {
  config: MigrationConfig;
  status: string;
  progress: MigrationProgress;
  tableProgress: TableProgress[];
  elapsedMs: number;
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

function timestamp(): string {
  return new Date().toISOString();
}

function formatMs(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  const seconds = ms / 1000;
  if (seconds < 60) return `${seconds.toFixed(1)}s`;
  const minutes = Math.floor(seconds / 60);
  const remaining = seconds % 60;
  return `${minutes}m ${remaining.toFixed(1)}s`;
}

function changeIcon(changeType: SchemaChange["changeType"]): string {
  switch (changeType) {
    case "Added":
      return "+";
    case "Removed":
      return "-";
    case "Modified":
      return "~";
    case "Unchanged":
      return " ";
  }
}

/** Escape a value for safe inclusion in a CSV field (RFC 4180). */
function escapeCsvField(value: unknown): string {
  const str = value === null || value === undefined ? "" : String(value);
  // Wrap in quotes if the value contains a comma, double-quote, or newline.
  if (str.includes('"') || str.includes(",") || str.includes("\n") || str.includes("\r")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

// ---------------------------------------------------------------------------
// Schema diff exports
// ---------------------------------------------------------------------------

/**
 * Generate a Markdown-formatted schema diff report.
 */
export function exportSchemaDiffAsMarkdown(diff: SchemaDiffResult): string {
  const lines: string[] = [];

  lines.push("# Schema Diff Report");
  lines.push("");
  lines.push(`**Generated:** ${timestamp()}`);
  lines.push("");
  lines.push(`**Source:** ${diff.sourceDatabase}`);
  lines.push(`**Target:** ${diff.targetDatabase}`);
  lines.push("");

  // Summary
  lines.push("## Summary");
  lines.push("");
  lines.push(`| Metric | Count |`);
  lines.push(`| --- | ---: |`);
  lines.push(`| Additions | ${diff.summary.additions} |`);
  lines.push(`| Removals | ${diff.summary.removals} |`);
  lines.push(`| Modifications | ${diff.summary.modifications} |`);
  lines.push(`| Unchanged | ${diff.summary.unchanged} |`);
  lines.push(`| **Total** | **${diff.changes.length}** |`);
  lines.push("");

  // Group changes by object type
  const grouped = new Map<string, SchemaChange[]>();
  for (const change of diff.changes) {
    const existing = grouped.get(change.objectType);
    if (existing) {
      existing.push(change);
    } else {
      grouped.set(change.objectType, [change]);
    }
  }

  lines.push("## Changes");
  lines.push("");

  if (diff.changes.length === 0) {
    lines.push("_No changes detected._");
    lines.push("");
  }

  for (const [objectType, changes] of grouped) {
    lines.push(`### ${objectType}s`);
    lines.push("");

    for (const change of changes) {
      lines.push(`- \`[${changeIcon(change.changeType)}]\` **${change.objectName}** (${change.changeType})`);

      if (change.details.length > 0) {
        for (const detail of change.details) {
          const src = detail.sourceValue ?? "_N/A_";
          const tgt = detail.targetValue ?? "_N/A_";
          lines.push(`  - ${detail.property}: ${src} -> ${tgt}`);
        }
      }
    }

    lines.push("");
  }

  lines.push("---");
  lines.push("_Report generated by Upsert._");

  return lines.join("\n");
}

/**
 * Generate a self-contained HTML schema diff report with inline CSS.
 */
export function exportSchemaDiffAsHtml(diff: SchemaDiffResult): string {
  const markdownBody = exportSchemaDiffAsMarkdown(diff);

  // Convert a subset of Markdown to HTML (enough for the report structure).
  const htmlBody = markdownToHtml(markdownBody);

  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Schema Diff Report - Upsert</title>
<style>
  :root { --bg: #ffffff; --fg: #1a1a1a; --muted: #6b7280; --border: #e5e7eb; --accent: #2563eb; --green: #16a34a; --red: #dc2626; --yellow: #ca8a04; }
  @media (prefers-color-scheme: dark) { :root { --bg: #1a1a2e; --fg: #e5e7eb; --muted: #9ca3af; --border: #374151; --accent: #60a5fa; --green: #4ade80; --red: #f87171; --yellow: #facc15; } }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--fg); line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 2rem 1rem; }
  h1 { font-size: 1.75rem; margin-bottom: 0.5rem; border-bottom: 2px solid var(--accent); padding-bottom: 0.5rem; }
  h2 { font-size: 1.35rem; margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--accent); }
  h3 { font-size: 1.1rem; margin-top: 1rem; margin-bottom: 0.3rem; }
  p { margin-bottom: 0.5rem; }
  table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
  th, td { text-align: left; padding: 0.4rem 0.75rem; border: 1px solid var(--border); }
  th { background: var(--border); font-weight: 600; }
  td:last-child { text-align: right; }
  code { background: var(--border); padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.9em; }
  ul { margin-left: 1.5rem; margin-bottom: 0.5rem; }
  li { margin-bottom: 0.2rem; }
  ul ul { margin-bottom: 0; }
  em { color: var(--muted); }
  strong { font-weight: 600; }
  hr { border: none; border-top: 1px solid var(--border); margin: 1.5rem 0; }
</style>
</head>
<body>
${htmlBody}
</body>
</html>`;
}

// ---------------------------------------------------------------------------
// Data diff exports
// ---------------------------------------------------------------------------

/**
 * Export data diff rows as CSV with proper RFC 4180 escaping.
 *
 * @param rows    - The row data to export.
 * @param columns - Ordered list of column names for the header row. Internal
 *                  columns (_rowId, _status, _changedColumns) are automatically
 *                  included as leading columns and do not need to be in the
 *                  columns array.
 */
export function exportDataDiffAsCsv(
  rows: DataDiffRow[],
  columns: string[],
): string {
  const metaColumns = ["_rowId", "_status", "_changedColumns"];
  const allColumns = [...metaColumns, ...columns];

  const headerLine = allColumns.map(escapeCsvField).join(",");

  const dataLines = rows.map((row) => {
    return allColumns
      .map((col) => {
        const value = col === "_changedColumns"
          ? (row._changedColumns ?? []).join(";")
          : row[col];
        return escapeCsvField(value);
      })
      .join(",");
  });

  return [headerLine, ...dataLines].join("\n");
}

/**
 * Export data diff rows as pretty-printed JSON.
 */
export function exportDataDiffAsJson(rows: DataDiffRow[]): string {
  return JSON.stringify(rows, null, 2);
}

// ---------------------------------------------------------------------------
// Migration exports
// ---------------------------------------------------------------------------

/**
 * Export a pre-migration plan as a Markdown summary.
 *
 * This is intended to be generated after configuration and (optionally) a dry
 * run, but before the actual migration starts.
 */
export function exportMigrationPlan(plan: MigrationPlanExport): string {
  const lines: string[] = [];
  const cfg = plan.config;

  lines.push("# Migration Plan");
  lines.push("");
  lines.push(`**Generated:** ${timestamp()}`);
  lines.push("");

  // Configuration overview
  lines.push("## Configuration");
  lines.push("");
  lines.push(`| Setting | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| Mode | ${cfg.mode} |`);
  lines.push(`| Conflict Resolution | ${cfg.conflictResolution} |`);
  lines.push(`| Batch Size | ${cfg.batchSize} |`);
  lines.push(`| Transaction Mode | ${cfg.transactionMode} |`);
  lines.push(`| Retry Count | ${cfg.retryCount} |`);
  lines.push(`| Auto Rollback | ${cfg.autoRollback ? "Yes" : "No"} |`);
  lines.push(`| Backup Before Migrate | ${cfg.backupBeforeMigrate ? "Yes" : "No"} |`);
  lines.push(`| Dry Run | ${cfg.dryRun ? "Yes" : "No"} |`);
  lines.push("");

  // Table mappings
  const included = plan.tableMappings.filter((m) => m.included);
  const excluded = plan.tableMappings.filter((m) => !m.included);

  lines.push("## Table Mappings");
  lines.push("");

  if (included.length === 0) {
    lines.push("_No tables selected for migration._");
  } else {
    lines.push(`| Source Table | Target Table | Est. Rows |`);
    lines.push(`| --- | --- | ---: |`);
    for (const m of included) {
      lines.push(`| ${m.sourceTable} | ${m.targetTable} | ${m.estimatedRows.toLocaleString()} |`);
    }
  }
  lines.push("");

  if (excluded.length > 0) {
    lines.push(`**Excluded tables (${excluded.length}):** ${excluded.map((m) => m.sourceTable).join(", ")}`);
    lines.push("");
  }

  // Transform rules
  if (plan.transformRules.length > 0) {
    lines.push("## Transform Rules");
    lines.push("");
    lines.push(`| # | Table | Source Column | Target Column | Rule |`);
    lines.push(`| ---: | --- | --- | --- | --- |`);

    const sorted = [...plan.transformRules].sort((a, b) => a.order - b.order);
    for (const rule of sorted) {
      const tableName =
        plan.tableMappings.find((m) => m.id === rule.tableId)?.sourceTable ??
        rule.tableId;
      lines.push(
        `| ${rule.order} | ${tableName} | ${rule.sourceColumn} | ${rule.targetColumn} | ${rule.ruleType} |`,
      );
    }
    lines.push("");
  }

  // Dry run results
  if (plan.dryRunResult) {
    const dr = plan.dryRunResult;
    lines.push("## Dry Run Results");
    lines.push("");

    if (dr.tableSummaries.length > 0) {
      lines.push(`| Table | Rows | Inserts | Updates | Deletes | Skips |`);
      lines.push(`| --- | ---: | ---: | ---: | ---: | ---: |`);
      for (const ts of dr.tableSummaries) {
        lines.push(
          `| ${ts.tableName} | ${ts.estimatedRows.toLocaleString()} | ${ts.estimatedInserts.toLocaleString()} | ${ts.estimatedUpdates.toLocaleString()} | ${ts.estimatedDeletes.toLocaleString()} | ${ts.estimatedSkips.toLocaleString()} |`,
        );
      }
      lines.push("");
    }

    lines.push(`**Estimated total time:** ${formatMs(dr.totalEstimatedTime)}`);
    lines.push("");

    if (dr.warnings.length > 0) {
      lines.push("### Warnings");
      lines.push("");
      for (const w of dr.warnings) {
        lines.push(`- ${w}`);
      }
      lines.push("");
    }

    if (dr.errors.length > 0) {
      lines.push("### Errors");
      lines.push("");
      for (const e of dr.errors) {
        lines.push(`- ${e}`);
      }
      lines.push("");
    }
  }

  lines.push("---");
  lines.push("_Report generated by Upsert._");

  return lines.join("\n");
}

/**
 * Export a post-migration summary as Markdown.
 */
export function exportMigrationSummary(result: MigrationResultExport): string {
  const lines: string[] = [];
  const prog = result.progress;

  lines.push("# Migration Summary");
  lines.push("");
  lines.push(`**Generated:** ${timestamp()}`);
  lines.push(`**Status:** ${result.status}`);
  lines.push(`**Duration:** ${formatMs(result.elapsedMs)}`);
  lines.push("");

  // Configuration recap
  lines.push("## Configuration");
  lines.push("");
  lines.push(`| Setting | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| Mode | ${result.config.mode} |`);
  lines.push(`| Conflict Resolution | ${result.config.conflictResolution} |`);
  lines.push(`| Batch Size | ${result.config.batchSize} |`);
  lines.push(`| Transaction Mode | ${result.config.transactionMode} |`);
  lines.push("");

  // Overall progress
  lines.push("## Overall Results");
  lines.push("");
  lines.push(`| Metric | Count |`);
  lines.push(`| --- | ---: |`);
  lines.push(`| Total Rows | ${prog.totalRows.toLocaleString()} |`);
  lines.push(`| Processed | ${prog.processedRows.toLocaleString()} |`);
  lines.push(`| Inserted | ${prog.insertedRows.toLocaleString()} |`);
  lines.push(`| Updated | ${prog.updatedRows.toLocaleString()} |`);
  lines.push(`| Deleted | ${prog.deletedRows.toLocaleString()} |`);
  lines.push(`| Skipped | ${prog.skippedRows.toLocaleString()} |`);
  lines.push(`| Errors | ${prog.errorCount.toLocaleString()} |`);
  lines.push("");

  if (prog.totalBatches > 0) {
    lines.push(`**Batches:** ${prog.currentBatch} / ${prog.totalBatches}`);
    lines.push("");
  }

  // Per-table breakdown
  if (result.tableProgress.length > 0) {
    lines.push("## Per-Table Breakdown");
    lines.push("");
    lines.push(`| Table | Status | Processed / Total | Errors |`);
    lines.push(`| --- | --- | ---: | ---: |`);

    for (const tp of result.tableProgress) {
      lines.push(
        `| ${tp.tableName} | ${tp.status} | ${tp.processedRows.toLocaleString()} / ${tp.totalRows.toLocaleString()} | ${tp.errors.length} |`,
      );
    }
    lines.push("");

    // List errors per table if any
    const tablesWithErrors = result.tableProgress.filter(
      (tp) => tp.errors.length > 0,
    );
    if (tablesWithErrors.length > 0) {
      lines.push("## Errors");
      lines.push("");

      for (const tp of tablesWithErrors) {
        lines.push(`### ${tp.tableName}`);
        lines.push("");
        for (const err of tp.errors) {
          const rowInfo =
            err.rowIndex !== undefined ? ` (row ${err.rowIndex})` : "";
          lines.push(`- ${err.message}${rowInfo}`);
        }
        lines.push("");
      }
    }
  }

  lines.push("---");
  lines.push("_Report generated by Upsert._");

  return lines.join("\n");
}

// ---------------------------------------------------------------------------
// File download helper
// ---------------------------------------------------------------------------

/**
 * Trigger a browser file download.
 *
 * Creates a temporary object URL from a Blob and clicks a hidden anchor to
 * start the download, then cleans up after itself.
 */
export function downloadFile(
  content: string,
  filename: string,
  mimeType: string,
): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);

  const anchor = document.createElement("a");
  anchor.href = url;
  anchor.download = filename;
  anchor.style.display = "none";

  document.body.appendChild(anchor);
  anchor.click();

  // Clean up after a short delay to ensure the download starts.
  setTimeout(() => {
    document.body.removeChild(anchor);
    URL.revokeObjectURL(url);
  }, 100);
}

// ---------------------------------------------------------------------------
// Minimal Markdown-to-HTML converter (internal)
// ---------------------------------------------------------------------------

/**
 * Convert the limited Markdown subset used by our report generators into HTML.
 *
 * This is intentionally minimal -- it covers headings, tables, bold, italic,
 * inline code, unordered lists (two levels), horizontal rules, and paragraphs.
 * It does NOT aim to be a general-purpose Markdown parser.
 */
function markdownToHtml(md: string): string {
  const lines = md.split("\n");
  const html: string[] = [];

  let inTable = false;
  let inTableBody = false;
  let inList = false;
  let inSubList = false;

  function closeTable(): void {
    if (inTableBody) {
      html.push("</tbody>");
      inTableBody = false;
    }
    if (inTable) {
      html.push("</table>");
      inTable = false;
    }
  }

  function closeList(): void {
    if (inSubList) {
      html.push("</ul></li>");
      inSubList = false;
    }
    if (inList) {
      html.push("</ul>");
      inList = false;
    }
  }

  function inlineFormat(text: string): string {
    // Inline code
    let result = text.replace(/`([^`]+)`/g, "<code>$1</code>");
    // Bold
    result = result.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
    // Italic (underscores for our _N/A_ style)
    result = result.replace(/\b_([^_]+)_\b/g, "<em>$1</em>");
    // Also handle _text_ at start/end of string
    result = result.replace(/(^|[^\\])_([^_]+)_/g, "$1<em>$2</em>");
    return result;
  }

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Horizontal rule
    if (/^---+$/.test(line)) {
      closeTable();
      closeList();
      html.push("<hr>");
      continue;
    }

    // Headings
    const headingMatch = /^(#{1,6})\s+(.*)$/.exec(line);
    if (headingMatch) {
      closeTable();
      closeList();
      const level = headingMatch[1].length;
      html.push(`<h${level}>${inlineFormat(headingMatch[2])}</h${level}>`);
      continue;
    }

    // Table separator line (skip it, we already used it to start tbody)
    if (/^\|[\s-:|]+\|$/.test(line)) {
      continue;
    }

    // Table row
    if (line.startsWith("|") && line.endsWith("|")) {
      const cells = line
        .slice(1, -1)
        .split("|")
        .map((c) => c.trim());

      if (!inTable) {
        // First table row => header
        inTable = true;
        html.push("<table>");
        html.push("<thead><tr>");
        for (const cell of cells) {
          html.push(`<th>${inlineFormat(cell)}</th>`);
        }
        html.push("</tr></thead>");
      } else {
        if (!inTableBody) {
          html.push("<tbody>");
          inTableBody = true;
        }
        html.push("<tr>");
        for (const cell of cells) {
          html.push(`<td>${inlineFormat(cell)}</td>`);
        }
        html.push("</tr>");
      }
      continue;
    }

    // If we were in a table and this line is not a table row, close it
    if (inTable) {
      closeTable();
    }

    // Nested list item (two-space indent)
    if (/^  - /.test(line)) {
      if (!inSubList) {
        // Remove the closing </li> from the parent item so we can nest inside it
        const lastEntry = html[html.length - 1];
        if (lastEntry === "</li>") {
          html.pop();
        }
        html.push("<ul>");
        inSubList = true;
      }
      html.push(`<li>${inlineFormat(line.replace(/^  - /, ""))}</li>`);
      continue;
    }

    // Top-level list item
    if (/^- /.test(line)) {
      if (inSubList) {
        html.push("</ul></li>");
        inSubList = false;
      }
      if (!inList) {
        inList = true;
        html.push("<ul>");
      }
      html.push(`<li>${inlineFormat(line.replace(/^- /, ""))}</li>`);
      continue;
    }

    // If we were in a list and this is no longer a list item, close the list
    if (inList) {
      closeList();
    }

    // Empty line
    if (line.trim() === "") {
      continue;
    }

    // Default: paragraph
    html.push(`<p>${inlineFormat(line)}</p>`);
  }

  closeTable();
  closeList();

  return html.join("\n");
}
